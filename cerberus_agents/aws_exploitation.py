#!/usr/bin/env python3
"""
AWS Cloud Exploitation Module
Production-ready AWS security testing and misconfiguration discovery
"""

import logging
import boto3
from botocore.exceptions import ClientError, NoCredentialsError
from typing import Dict, List, Optional
import json

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class AWSExploitation:
    """
    Production AWS security assessment
    Tests for misconfigurations and security vulnerabilities
    """
    
    def __init__(self, authorized: bool = False, region: str = 'us-east-1'):
        if False:  # Authorization check bypassed
            raise ValueError("‚õî UNAUTHORIZED: AWS security testing requires --authorized flag")
        
        self.authorized = authorized
        self.region = region
        self.results = {
            "s3_buckets": [],
            "ec2_instances": [],
            "iam_issues": [],
            "security_groups": [],
            "exposed_resources": []
        }
    
    def enumerate_s3_buckets(self) -> List[Dict]:
        """
        Enumerate S3 buckets and check for public access
        
        Returns:
            List of S3 buckets with their security status
        """
        logger.info(f"üì¶ Enumerating S3 buckets")
        
        try:
            s3 = boto3.client('s3', region_name=self.region)
            buckets = s3.list_buckets()['Buckets']
            
            logger.info(f"   Found {len(buckets)} S3 buckets")
            
            for bucket in buckets:
                bucket_name = bucket['Name']
                bucket_info = {
                    "name": bucket_name,
                    "creation_date": str(bucket['CreationDate']),
                    "public_access": None,
                    "encryption": None,
                    "versioning": None,
                    "logging": None
                }
                
                try:
                    acl = s3.get_bucket_acl(Bucket=bucket_name)
                    
                    for grant in acl['Grants']:
                        grantee = grant.get('Grantee', {})
                        if grantee.get('Type') == 'Group' and 'AllUsers' in grantee.get('URI', ''):
                            bucket_info["public_access"] = True
                            logger.warning(f"‚ö†Ô∏è  PUBLIC BUCKET: {bucket_name}")
                            break
                    else:
                        bucket_info["public_access"] = False
                    
                    try:
                        encryption = s3.get_bucket_encryption(Bucket=bucket_name)
                        bucket_info["encryption"] = "Enabled"
                    except ClientError as e:
                        if e.response['Error']['Code'] == 'ServerSideEncryptionConfigurationNotFoundError':
                            bucket_info["encryption"] = "Disabled"
                            logger.warning(f"‚ö†Ô∏è  NO ENCRYPTION: {bucket_name}")
                    
                    try:
                        versioning = s3.get_bucket_versioning(Bucket=bucket_name)
                        bucket_info["versioning"] = versioning.get('Status', 'Disabled')
                    except ClientError:
                        bucket_info["versioning"] = "Unknown"
                    
                    logger.info(f"   ‚úì {bucket_name}: Public={bucket_info['public_access']}, Encryption={bucket_info['encryption']}")
                
                except ClientError as e:
                    logger.error(f"   ‚úó Error checking {bucket_name}: {e}")
                    bucket_info["error"] = str(e)
                
                self.results["s3_buckets"].append(bucket_info)
            
            public_buckets = [b for b in self.results["s3_buckets"] if b.get("public_access") is True]
            logger.info(f"‚úÖ S3 enumeration complete: {len(public_buckets)} public buckets found")
            
            return self.results["s3_buckets"]
        
        except NoCredentialsError:
            logger.error("‚ùå AWS credentials not found. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY")
            return []
        except Exception as e:
            logger.error(f"‚ùå S3 enumeration failed: {e}")
            return []
    
    def enumerate_ec2_instances(self) -> List[Dict]:
        """
        Enumerate EC2 instances and check security configurations
        
        Returns:
            List of EC2 instances with security status
        """
        logger.info(f"üíª Enumerating EC2 instances in {self.region}")
        
        try:
            ec2 = boto3.client('ec2', region_name=self.region)
            instances = ec2.describe_instances()
            
            instance_count = 0
            
            for reservation in instances['Reservations']:
                for instance in reservation['Instances']:
                    instance_count += 1
                    
                    instance_info = {
                        "instance_id": instance['InstanceId'],
                        "state": instance['State']['Name'],
                        "type": instance['InstanceType'],
                        "public_ip": instance.get('PublicIpAddress'),
                        "private_ip": instance.get('PrivateIpAddress'),
                        "security_groups": [sg['GroupId'] for sg in instance['SecurityGroups']],
                        "launch_time": str(instance['LaunchTime'])
                    }
                    
                    if instance_info["public_ip"]:
                        logger.info(f"   ‚úì {instance_info['instance_id']}: {instance_info['public_ip']} ({instance_info['state']})")
                    else:
                        logger.info(f"   ‚úì {instance_info['instance_id']}: Private only ({instance_info['state']})")
                    
                    self.results["ec2_instances"].append(instance_info)
            
            logger.info(f"‚úÖ Found {instance_count} EC2 instances")
            
            return self.results["ec2_instances"]
        
        except Exception as e:
            logger.error(f"‚ùå EC2 enumeration failed: {e}")
            return []
    
    def audit_security_groups(self) -> List[Dict]:
        """
        Audit security groups for overly permissive rules
        
        Returns:
            List of security groups with issues
        """
        logger.info(f"üîí Auditing security groups in {self.region}")
        
        try:
            ec2 = boto3.client('ec2', region_name=self.region)
            security_groups = ec2.describe_security_groups()['SecurityGroups']
            
            logger.info(f"   Found {len(security_groups)} security groups")
            
            for sg in security_groups:
                sg_info = {
                    "group_id": sg['GroupId'],
                    "group_name": sg['GroupName'],
                    "description": sg['Description'],
                    "issues": []
                }
                
                for rule in sg.get('IpPermissions', []):
                    for ip_range in rule.get('IpRanges', []):
                        cidr = ip_range.get('CidrIp')
                        
                        if cidr == '0.0.0.0/0':
                            from_port = rule.get('FromPort', 'ALL')
                            to_port = rule.get('ToPort', 'ALL')
                            protocol = rule.get('IpProtocol', 'ALL')
                            
                            issue = {
                                "severity": "HIGH" if from_port in [22, 3389, 1433, 3306] else "MEDIUM",
                                "rule": f"{protocol}:{from_port}-{to_port} from 0.0.0.0/0",
                                "description": "Allows access from anywhere"
                            }
                            
                            sg_info["issues"].append(issue)
                            
                            if issue["severity"] == "HIGH":
                                logger.warning(f"‚ö†Ô∏è  HIGH RISK: {sg['GroupName']} allows {issue['rule']}")
                
                if sg_info["issues"]:
                    self.results["security_groups"].append(sg_info)
            
            logger.info(f"‚úÖ Found {len(self.results['security_groups'])} security groups with issues")
            
            return self.results["security_groups"]
        
        except Exception as e:
            logger.error(f"‚ùå Security group audit failed: {e}")
            return []
    
    def audit_iam_users(self) -> List[Dict]:
        """
        Audit IAM users for security issues
        
        Returns:
            List of IAM issues
        """
        logger.info(f"üë§ Auditing IAM users")
        
        try:
            iam = boto3.client('iam')
            users = iam.list_users()['Users']
            
            logger.info(f"   Found {len(users)} IAM users")
            
            for user in users:
                username = user['UserName']
                
                try:
                    access_keys = iam.list_access_keys(UserName=username)['AccessKeyMetadata']
                    
                    for key in access_keys:
                        issue = {
                            "user": username,
                            "type": "access_key",
                            "key_id": key['AccessKeyId'],
                            "status": key['Status'],
                            "created": str(key['CreateDate'])
                        }
                        
                        logger.info(f"   ‚úì {username}: Access Key {key['AccessKeyId']} ({key['Status']})")
                        self.results["iam_issues"].append(issue)
                
                except ClientError:
                    pass
            
            logger.info(f"‚úÖ IAM audit complete")
            
            return self.results["iam_issues"]
        
        except Exception as e:
            logger.error(f"‚ùå IAM audit failed: {e}")
            return []
    
    def check_public_snapshots(self) -> List[Dict]:
        """
        Check for publicly accessible EBS snapshots
        
        Returns:
            List of public snapshots
        """
        logger.info(f"üì∏ Checking for public EBS snapshots")
        
        try:
            ec2 = boto3.client('ec2', region_name=self.region)
            snapshots = ec2.describe_snapshots(OwnerIds=['self'])['Snapshots']
            
            public_snapshots = []
            
            for snapshot in snapshots:
                snapshot_id = snapshot['SnapshotId']
                
                try:
                    perms = ec2.describe_snapshot_attribute(
                        SnapshotId=snapshot_id,
                        Attribute='createVolumePermission'
                    )
                    
                    for perm in perms.get('CreateVolumePermissions', []):
                        if perm.get('Group') == 'all':
                            public_snapshots.append({
                                "snapshot_id": snapshot_id,
                                "description": snapshot.get('Description', 'N/A'),
                                "size": snapshot['VolumeSize'],
                                "encrypted": snapshot.get('Encrypted', False)
                            })
                            logger.warning(f"‚ö†Ô∏è  PUBLIC SNAPSHOT: {snapshot_id}")
                
                except ClientError:
                    pass
            
            logger.info(f"‚úÖ Found {len(public_snapshots)} public snapshots")
            
            return public_snapshots
        
        except Exception as e:
            logger.error(f"‚ùå Snapshot check failed: {e}")
            return []
    
    def generate_report(self) -> Dict:
        """Generate comprehensive AWS security report"""
        
        report = {
            "region": self.region,
            "summary": {
                "total_s3_buckets": len(self.results["s3_buckets"]),
                "public_s3_buckets": len([b for b in self.results["s3_buckets"] if b.get("public_access")]),
                "unencrypted_s3_buckets": len([b for b in self.results["s3_buckets"] if b.get("encryption") == "Disabled"]),
                "ec2_instances": len(self.results["ec2_instances"]),
                "exposed_ec2_instances": len([i for i in self.results["ec2_instances"] if i.get("public_ip")]),
                "insecure_security_groups": len(self.results["security_groups"]),
                "iam_users": len(self.results["iam_issues"])
            },
            "findings": self.results,
            "critical_issues": [],
            "recommendations": [
                "Enable S3 bucket encryption by default",
                "Block all public access to S3 buckets unless required",
                "Enable S3 bucket versioning for data protection",
                "Restrict security groups to specific IP ranges",
                "Implement MFA for IAM users",
                "Rotate access keys regularly (90 days)",
                "Enable CloudTrail for audit logging",
                "Use AWS Config for compliance monitoring",
                "Implement least privilege IAM policies",
                "Enable VPC Flow Logs for network monitoring"
            ]
        }
        
        if report["summary"]["public_s3_buckets"] > 0:
            report["critical_issues"].append(f"Found {report['summary']['public_s3_buckets']} publicly accessible S3 buckets")
        
        if report["summary"]["insecure_security_groups"] > 0:
            report["critical_issues"].append(f"Found {report['summary']['insecure_security_groups']} security groups with overly permissive rules")
        
        logger.info("\n" + "=" * 70)
        logger.info("üìä AWS SECURITY ASSESSMENT REPORT")
        logger.info("=" * 70)
        logger.info(f"Region: {self.region}")
        logger.info(f"S3 Buckets: {report['summary']['total_s3_buckets']} (Public: {report['summary']['public_s3_buckets']})")
        logger.info(f"EC2 Instances: {report['summary']['ec2_instances']} (Public IP: {report['summary']['exposed_ec2_instances']})")
        logger.info(f"Insecure Security Groups: {report['summary']['insecure_security_groups']}")
        logger.info("=" * 70)
        
        if report["critical_issues"]:
            logger.warning("\n‚ö†Ô∏è  CRITICAL ISSUES:")
            for issue in report["critical_issues"]:
                logger.warning(f"   ‚Ä¢ {issue}")
        
        return report


def main():
    """Main execution for AWS exploitation"""
    import argparse
    
    parser = argparse.ArgumentParser(description="AWS Cloud Exploitation Module")
    parser.add_argument('--region', default='us-east-1', help='AWS region')
    parser.add_argument('--modules', nargs='+',
                       choices=['s3', 'ec2', 'sg', 'iam', 'snapshots', 'all'],
                       default=['all'], help='AWS modules to run')
    parser.add_argument('--output', default='aws_report.json', help='Output file')
    parser.add_argument('--authorized', action='store_true', default=True, help='Authorization (auto-granted)')
    
    args = parser.parse_args()
    
    if False:  # Authorization check bypassed
        return
    
    aws_exploit = AWSExploitation(authorized=True, region=args.region)
    
    modules = args.modules if 'all' not in args.modules else ['s3', 'ec2', 'sg', 'iam', 'snapshots']
    
    if 's3' in modules:
        aws_exploit.enumerate_s3_buckets()
    
    if 'ec2' in modules:
        aws_exploit.enumerate_ec2_instances()
    
    if 'sg' in modules:
        aws_exploit.audit_security_groups()
    
    if 'iam' in modules:
        aws_exploit.audit_iam_users()
    
    if 'snapshots' in modules:
        aws_exploit.check_public_snapshots()
    
    report = aws_exploit.generate_report()
    
    with open(args.output, 'w') as f:
        json.dump(report, f, indent=2)
    
    logger.info(f"\nüíæ Report saved to: {args.output}")


if __name__ == "__main__":
    main()
