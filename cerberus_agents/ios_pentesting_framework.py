#!/usr/bin/env python3
"""
iOS Pentesting Framework
Comprehensive iOS/iPadOS/Apple device security assessment
Frida, Objection, MobSF, iMazing integration
"""

import subprocess
import json
import logging
import os
from typing import Dict, List, Optional
from pathlib import Path

logger = logging.getLogger(__name__)


class iOSPentestingFramework:
    """
    iOS Pentesting Framework
    Dynamic and static analysis of iOS applications
    """
    
    def __init__(self):
        self.frida_installed = self._check_frida()
        self.objection_installed = self._check_objection()
        self.mobsf_installed = self._check_mobsf()
        
    def _check_frida(self) -> bool:
        """Check if Frida is installed"""
        result = subprocess.run(["which", "frida"], capture_output=True)
        return result.returncode == 0
    
    def _check_objection(self) -> bool:
        """Check if Objection is installed"""
        result = subprocess.run(["which", "objection"], capture_output=True)
        return result.returncode == 0
    
    def _check_mobsf(self) -> bool:
        """Check if MobSF is available"""
        return os.path.exists(os.path.expanduser("~/tools/MobSF"))
    
    def install_tools(self) -> Dict[str, any]:
        """Install iOS pentesting tools"""
        logger.info("Installing iOS pentesting tools...")
        
        results = {}
        
        try:
            logger.info("Installing Frida...")
            result = subprocess.run(
                ["pip3", "install", "frida-tools"],
                capture_output=True,
                text=True,
                timeout=300
            )
            results["frida"] = result.returncode == 0
            
            logger.info("Installing Objection...")
            result = subprocess.run(
                ["pip3", "install", "objection"],
                capture_output=True,
                text=True,
                timeout=300
            )
            results["objection"] = result.returncode == 0
            
            logger.info("Installing MobSF dependencies...")
            result = subprocess.run(
                ["pip3", "install", "mobsf"],
                capture_output=True,
                text=True,
                timeout=300
            )
            results["mobsf"] = result.returncode == 0
            
            self.frida_installed = results.get("frida", False)
            self.objection_installed = results.get("objection", False)
            self.mobsf_installed = results.get("mobsf", False)
            
            return {
                "success": all(results.values()),
                "results": results,
                "message": "iOS pentesting tools installed"
            }
            
        except Exception as e:
            logger.error(f"Installation failed: {e}")
            return {"success": False, "error": str(e)}
    
    def list_devices(self) -> Dict[str, any]:
        """List connected iOS devices via Frida"""
        if not self.frida_installed:
            return {"success": False, "error": "Frida not installed"}
        
        logger.info("Listing connected iOS devices...")
        
        try:
            result = subprocess.run(
                ["frida-ls-devices"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                "success": True,
                "devices": result.stdout,
                "note": "Devices must have Frida server running"
            }
            
        except Exception as e:
            logger.error(f"Device listing failed: {e}")
            return {"success": False, "error": str(e)}
    
    def list_apps(self, device_id: str = "usb") -> Dict[str, any]:
        """
        List installed apps on iOS device
        
        Args:
            device_id: Device ID or 'usb' for USB device
        """
        if not self.frida_installed:
            return {"success": False, "error": "Frida not installed"}
        
        logger.info(f"Listing apps on device: {device_id}")
        
        try:
            result = subprocess.run(
                ["frida-ps", "-D", device_id, "-a"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return {
                "success": True,
                "apps": result.stdout,
                "device": device_id
            }
            
        except Exception as e:
            logger.error(f"App listing failed: {e}")
            return {"success": False, "error": str(e)}
    
    def explore_app(self, app_bundle: str, device_id: str = "usb") -> Dict[str, any]:
        """
        Launch Objection to explore iOS app
        
        Args:
            app_bundle: App bundle identifier (e.g., com.example.app)
            device_id: Device ID
        """
        if not self.objection_installed:
            return {"success": False, "error": "Objection not installed"}
        
        logger.info(f"Exploring app: {app_bundle}")
        
        try:
            cmd = ["objection", "-d", device_id, "-g", app_bundle, "explore"]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            return {
                "success": True,
                "message": f"Objection session started for {app_bundle}",
                "pid": process.pid,
                "commands": [
                    "env - Show environment",
                    "ios plist cat Info.plist - Read plist files",
                    "ios keychain dump - Dump keychain",
                    "ios cookies get - Get cookies",
                    "ios nsurlcredentialstorage dump - Dump credentials",
                    "ios ui dump - Dump UI hierarchy",
                    "memory list modules - List loaded modules",
                    "memory search - Search memory"
                ]
            }
            
        except Exception as e:
            logger.error(f"App exploration failed: {e}")
            return {"success": False, "error": str(e)}
    
    def bypass_ssl_pinning(self, app_bundle: str, device_id: str = "usb") -> Dict[str, any]:
        """
        Bypass SSL pinning in iOS app
        
        Args:
            app_bundle: App bundle identifier
            device_id: Device ID
        """
        logger.info(f"Bypassing SSL pinning for {app_bundle}")
        
        try:
            cmd = [
                "objection",
                "-d", device_id,
                "-g", app_bundle,
                "explore",
                "-s", "ios sslpinning disable"
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            return {
                "success": True,
                "message": f"SSL pinning bypass attempted for {app_bundle}",
                "pid": process.pid,
                "note": "Use Burp Suite to intercept HTTPS traffic"
            }
            
        except Exception as e:
            logger.error(f"SSL pinning bypass failed: {e}")
            return {"success": False, "error": str(e)}
    
    def dump_keychain(self, app_bundle: str, device_id: str = "usb") -> Dict[str, any]:
        """
        Dump iOS keychain for app
        
        Args:
            app_bundle: App bundle identifier
            device_id: Device ID
        """
        logger.info(f"Dumping keychain for {app_bundle}")
        
        try:
            cmd = [
                "objection",
                "-d", device_id,
                "-g", app_bundle,
                "explore",
                "-q", "ios keychain dump"
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            return {
                "success": True,
                "keychain_data": result.stdout,
                "app": app_bundle
            }
            
        except Exception as e:
            logger.error(f"Keychain dump failed: {e}")
            return {"success": False, "error": str(e)}
    
    def analyze_ipa(self, ipa_path: str) -> Dict[str, any]:
        """
        Static analysis of IPA file
        
        Args:
            ipa_path: Path to .ipa file
        """
        if not os.path.exists(ipa_path):
            return {"success": False, "error": f"IPA file not found: {ipa_path}"}
        
        logger.info(f"Analyzing IPA: {ipa_path}")
        
        analysis_results = {
            "file": ipa_path,
            "checks": []
        }
        
        try:
            import zipfile
            
            with zipfile.ZipFile(ipa_path, 'r') as zip_ref:
                file_list = zip_ref.namelist()
                
                analysis_results["checks"].append({
                    "check": "File structure",
                    "files_count": len(file_list)
                })
                
                for file in file_list:
                    if "Info.plist" in file:
                        analysis_results["checks"].append({
                            "check": "Info.plist found",
                            "path": file
                        })
                    
                    if ".mobileprovision" in file:
                        analysis_results["checks"].append({
                            "check": "Provisioning profile found",
                            "path": file
                        })
            
            return {
                "success": True,
                "analysis": analysis_results,
                "note": "Use MobSF for comprehensive analysis"
            }
            
        except Exception as e:
            logger.error(f"IPA analysis failed: {e}")
            return {"success": False, "error": str(e)}
    
    def extract_app_data(self, app_bundle: str, device_id: str = "usb",
                         output_dir: str = "/tmp/ios_data") -> Dict[str, any]:
        """
        Extract app data from device
        
        Args:
            app_bundle: App bundle identifier
            device_id: Device ID
            output_dir: Output directory
        """
        logger.info(f"Extracting data for {app_bundle}")
        
        os.makedirs(output_dir, exist_ok=True)
        
        commands = [
            f"ios plist cat Info.plist > {output_dir}/Info.plist",
            f"ios cookies get > {output_dir}/cookies.json",
            f"ios nsurlcredentialstorage dump > {output_dir}/credentials.txt"
        ]
        
        return {
            "success": True,
            "message": f"Data extraction configured for {app_bundle}",
            "output_dir": output_dir,
            "commands": commands,
            "note": "Execute commands in Objection interactive session"
        }


def demonstrate_ios_pentesting():
    """Demonstrate iOS pentesting capabilities"""
    print("\n" + "="*70)
    print("iOS PENTESTING FRAMEWORK")
    print("="*70)
    
    ios_framework = iOSPentestingFramework()
    
    print("\n[*] Production Tools:")
    print("    ✓ Frida - Dynamic instrumentation framework")
    print("    ✓ Objection - Runtime mobile exploration")
    print("    ✓ MobSF - Mobile security framework (SAST/DAST)")
    print("    ✓ iMazing - iOS device manager (not integrated)")
    
    print("\n[*] Capabilities:")
    print("    • Runtime code injection (Frida)")
    print("    • SSL pinning bypass")
    print("    • Keychain dumping")
    print("    • Method hooking and tracing")
    print("    • IPA static analysis")
    print("    • File system exploration")
    print("    • Memory analysis")
    print("    • Network traffic interception")
    
    print("\n[*] Workflow:")
    print("    1. List devices: list_devices()")
    print("    2. List apps: list_apps('usb')")
    print("    3. Explore app: explore_app('com.example.app')")
    print("    4. Bypass SSL: bypass_ssl_pinning('com.example.app')")
    print("    5. Dump keychain: dump_keychain('com.example.app')")
    print("    6. Analyze IPA: analyze_ipa('app.ipa')")
    
    print("\n[*] Requirements:")
    print("    • Jailbroken iOS device (for full access)")
    print("    • Frida server running on device")
    print("    • USB connection or network access")
    print("    • App installed on device")
    
    print("\n[!] Authorization Required: Device must be owned or authorized")
    print("="*70)


if __name__ == "__main__":
    demonstrate_ios_pentesting()
