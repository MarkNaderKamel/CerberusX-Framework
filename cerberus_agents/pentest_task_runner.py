#!/usr/bin/env python3
"""
Pentest Task Runner

Orchestration engine to run external security tools (Nmap, Nikto, etc.)
with subprocess management, timeouts, and result parsing.

Usage:
    python -m cerberus_agents.pentest_task_runner --config config/pentest_tasks.json
"""

import argparse
import json
import subprocess
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import shlex
import time

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class PentestTaskRunner:
    def __init__(self, config_file: str, results_dir: str = "orchestration_results"):
        self.config_file = Path(config_file)
        self.results_dir = Path(results_dir)
        self.results_dir.mkdir(exist_ok=True)
        self.tasks = self.load_tasks()
        self.results = []
    
    def load_tasks(self) -> List[Dict]:
        """Load pentest tasks from configuration"""
        if not self.config_file.exists():
            logger.error(f"âŒ Config file not found: {self.config_file}")
            return []
        
        try:
            with self.config_file.open() as f:
                config = json.load(f)
                tasks = config.get("tasks", [])
                logger.info(f"âœ“ Loaded {len(tasks)} tasks from config")
                return tasks
        except Exception as e:
            logger.error(f"âŒ Error loading config: {e}")
            return []
    
    def check_tool_available(self, tool: str) -> bool:
        """Check if a tool is available in PATH"""
        try:
            result = subprocess.run(
                ["which", tool] if tool != "nmap" else [tool, "--version"],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def run_task(self, task: Dict) -> Dict:
        """Execute a single task with timeout"""
        task_name = task.get("name", "unknown")
        command = task.get("command", "")
        timeout = task.get("timeout", 300)
        parse_output = task.get("parse_output", False)
        
        logger.info(f"\nğŸ”§ Running task: {task_name}")
        logger.info(f"   Command: {command}")
        logger.info(f"   Timeout: {timeout}s")
        
        result = {
            "task_name": task_name,
            "command": command,
            "start_time": datetime.now().isoformat(),
            "status": "unknown",
            "stdout": "",
            "stderr": "",
            "return_code": -1,
            "execution_time": 0
        }
        
        start_time = time.time()
        
        try:
            process = subprocess.run(
                shlex.split(command),
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            execution_time = time.time() - start_time
            
            result["stdout"] = process.stdout
            result["stderr"] = process.stderr
            result["return_code"] = process.returncode
            result["execution_time"] = round(execution_time, 2)
            result["status"] = "completed" if process.returncode == 0 else "failed"
            
            logger.info(f"   âœ“ Task completed in {execution_time:.2f}s")
            
            if parse_output:
                result["parsed_data"] = self.parse_output(process.stdout, task_name)
            
        except subprocess.TimeoutExpired:
            result["status"] = "timeout"
            result["execution_time"] = timeout
            logger.error(f"   âŒ Task timed out after {timeout}s")
            
        except FileNotFoundError:
            result["status"] = "tool_not_found"
            result["error"] = f"Tool not found in PATH"
            logger.error(f"   âŒ Tool not found")
            
        except Exception as e:
            result["status"] = "error"
            result["error"] = str(e)
            logger.error(f"   âŒ Error: {e}")
        
        result["end_time"] = datetime.now().isoformat()
        
        output_file = self.results_dir / f"{task_name.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with output_file.open("w") as f:
            json.dump(result, f, indent=2)
        
        logger.info(f"   ğŸ“„ Output saved to: {output_file.name}")
        
        return result
    
    def parse_output(self, output: str, task_name: str) -> Dict:
        """Parse tool output based on task type"""
        parsed = {"raw_output": output}
        
        if "nmap" in task_name.lower():
            parsed["type"] = "nmap"
            parsed["open_ports"] = []
            
            for line in output.splitlines():
                if "/tcp" in line or "/udp" in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        parsed["open_ports"].append({
                            "port": parts[0],
                            "state": parts[1] if len(parts) > 1 else "unknown",
                            "service": parts[2] if len(parts) > 2 else "unknown"
                        })
        
        elif "nikto" in task_name.lower():
            parsed["type"] = "nikto"
            parsed["findings"] = []
            
            for line in output.splitlines():
                if "+ " in line:
                    parsed["findings"].append(line.strip())
        
        else:
            parsed["type"] = "generic"
            parsed["lines"] = output.splitlines()
        
        return parsed
    
    def run_all_tasks(self):
        """Execute all configured tasks"""
        logger.info("=" * 60)
        logger.info("ğŸ›¡ï¸  CERBERUS PENTEST TASK RUNNER")
        logger.info("=" * 60)
        
        if not Path("config/allowed_targets.yml").exists():
            logger.error("âŒ ABORTED: No authorization file (allowed_targets.yml) found")
            return
        
        logger.info("âœ“ Authorization verified")
        
        if not self.tasks:
            logger.error("âŒ No tasks to execute")
            return
        
        logger.info(f"ğŸ“‹ Total tasks: {len(self.tasks)}\n")
        
        for idx, task in enumerate(self.tasks, 1):
            logger.info(f"[{idx}/{len(self.tasks)}]")
            
            if task.get("enabled", True):
                result = self.run_task(task)
                self.results.append(result)
            else:
                logger.info(f"â­ï¸  Skipping disabled task: {task.get('name', 'unknown')}")
        
        summary = {
            "execution_date": datetime.now().isoformat(),
            "total_tasks": len(self.tasks),
            "completed": sum(1 for r in self.results if r["status"] == "completed"),
            "failed": sum(1 for r in self.results if r["status"] == "failed"),
            "timeout": sum(1 for r in self.results if r["status"] == "timeout"),
            "errors": sum(1 for r in self.results if r["status"] == "error"),
            "results": self.results
        }
        
        summary_file = self.results_dir / f"summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with summary_file.open("w") as f:
            json.dump(summary, f, indent=2)
        
        logger.info("\n" + "=" * 60)
        logger.info("ğŸ“Š EXECUTION SUMMARY")
        logger.info("=" * 60)
        logger.info(f"Total Tasks: {summary['total_tasks']}")
        logger.info(f"Completed: {summary['completed']}")
        logger.info(f"Failed: {summary['failed']}")
        logger.info(f"Timeout: {summary['timeout']}")
        logger.info(f"Errors: {summary['errors']}")
        logger.info(f"\nâœ… Orchestration complete!")
        logger.info(f"ğŸ“ Results directory: {self.results_dir.absolute()}")
        logger.info(f"ğŸ“„ Summary: {summary_file.absolute()}")


def main():
    parser = argparse.ArgumentParser(description="Pentest Task Runner")
    parser.add_argument("--config", default="config/pentest_tasks.json", help="Task configuration file")
    parser.add_argument("--results-dir", default="orchestration_results", help="Results directory")
    parser.add_argument('--authorized', action='store_true',
                       help='Confirm you have authorization to perform this action')
    args = parser.parse_args()
    
    runner = PentestTaskRunner(args.config, args.results_dir)
    runner.run_all_tasks()


if __name__ == "__main__":
    main()
