#!/usr/bin/env python3
"""
Production-Ready Android Pentesting Suite
Comprehensive mobile security testing without external tool dependencies
"""

import subprocess
import os
import json
import hashlib
import zipfile
import tempfile
from typing import Dict, List, Optional
from pathlib import Path
import re


class AndroidPentestingSuite:
    """
    Production-Ready Android Security Testing
    Pure Python implementation for maximum portability
    """
    
    def __init__(self):
        self.adb_available = self._check_command('adb')
        self.aapt_available = self._check_command('aapt')
    
    def _check_command(self, cmd: str) -> bool:
        """Check if command is available"""
        try:
            subprocess.run([cmd, '--version'], capture_output=True, timeout=5)
            return True
        except:
            try:
                subprocess.run([cmd, 'version'], capture_output=True, timeout=5)
                return True
            except:
                return False
    
    def analyze_apk_manifest(self, apk_path: str) -> Dict:
        """Analyze APK manifest for security issues (Pure Python)"""
        if not os.path.exists(apk_path):
            return {"error": f"APK not found: {apk_path}"}
        
        analysis = {
            "apk": apk_path,
            "package_name": None,
            "version": None,
            "min_sdk": None,
            "target_sdk": None,
            "permissions": [],
            "activities": [],
            "services": [],
            "receivers": [],
            "providers": [],
            "exported_components": [],
            "debuggable": False,
            "allow_backup": True,
            "network_security_config": False,
            "uses_cleartext_traffic": True,
            "security_issues": []
        }
        
        try:
            with zipfile.ZipFile(apk_path, 'r') as zf:
                if 'AndroidManifest.xml' in zf.namelist():
                    manifest_data = zf.read('AndroidManifest.xml')
                    
                    analysis["manifest_found"] = True
                    analysis["manifest_size"] = len(manifest_data)
                else:
                    analysis["error"] = "AndroidManifest.xml not found in APK"
                    return analysis
                
                if self.aapt_available:
                    try:
                        result = subprocess.run(
                            ['aapt', 'dump', 'badging', apk_path],
                            capture_output=True,
                            text=True,
                            timeout=30
                        )
                        
                        for line in result.stdout.splitlines():
                            if line.startswith('package:'):
                                match = re.search(r"name='([^']+)'", line)
                                if match:
                                    analysis["package_name"] = match.group(1)
                                match = re.search(r"versionName='([^']+)'", line)
                                if match:
                                    analysis["version"] = match.group(1)
                            
                            elif line.startswith('sdkVersion:'):
                                analysis["min_sdk"] = line.split(':')[1].strip().strip("'")
                            
                            elif line.startswith('targetSdkVersion:'):
                                analysis["target_sdk"] = line.split(':')[1].strip().strip("'")
                            
                            elif line.startswith('uses-permission:'):
                                match = re.search(r"name='([^']+)'", line)
                                if match:
                                    analysis["permissions"].append(match.group(1))
                        
                        result = subprocess.run(
                            ['aapt', 'dump', 'xmltree', apk_path, 'AndroidManifest.xml'],
                            capture_output=True,
                            text=True,
                            timeout=30
                        )
                        
                        if 'android:debuggable(0x0101000f)=(type 0x12)0xffffffff' in result.stdout:
                            analysis["debuggable"] = True
                            analysis["security_issues"].append("CRITICAL: Application is debuggable")
                        
                        if 'android:allowBackup(0x01010280)=(type 0x12)0x0' in result.stdout:
                            analysis["allow_backup"] = False
                        elif 'allowBackup' not in result.stdout:
                            analysis["security_issues"].append("WARNING: Backup is enabled (default)")
                        
                        if 'android:usesCleartextTraffic' in result.stdout:
                            if '0x0' in result.stdout:
                                analysis["uses_cleartext_traffic"] = False
                        
                        if 'networkSecurityConfig' in result.stdout:
                            analysis["network_security_config"] = True
                    except Exception as e:
                        analysis["aapt_error"] = f"AAPT analysis failed: {str(e)}"
                        analysis["security_issues"].append("WARNING: Full manifest analysis unavailable (AAPT required)")
                else:
                    analysis["aapt_error"] = "AAPT not available - limited analysis only"
                    analysis["security_issues"].append("INFO: Install AAPT for comprehensive manifest analysis")
                
                files = zf.namelist()
                analysis["total_files"] = len(files)
                analysis["dex_files"] = [f for f in files if f.endswith('.dex')]
                analysis["so_files"] = [f for f in files if f.endswith('.so')]
                analysis["has_native_code"] = len(analysis["so_files"]) > 0
                
            self._analyze_permissions_risk(analysis)
            
            return analysis
        
        except Exception as e:
            return {"error": str(e), "apk": apk_path}
    
    def _analyze_permissions_risk(self, analysis: Dict):
        """Analyze permission risks"""
        dangerous_perms = {
            'INTERNET': 'Network access',
            'READ_CONTACTS': 'Access contacts',
            'WRITE_CONTACTS': 'Modify contacts',
            'ACCESS_FINE_LOCATION': 'Precise location',
            'ACCESS_COARSE_LOCATION': 'Approximate location',
            'CAMERA': 'Camera access',
            'RECORD_AUDIO': 'Microphone access',
            'READ_PHONE_STATE': 'Phone state/IMEI',
            'CALL_PHONE': 'Make phone calls',
            'SEND_SMS': 'Send SMS',
            'RECEIVE_SMS': 'Receive SMS',
            'READ_SMS': 'Read SMS',
            'WRITE_EXTERNAL_STORAGE': 'Write to storage',
            'READ_EXTERNAL_STORAGE': 'Read from storage',
            'GET_ACCOUNTS': 'Access device accounts',
            'READ_CALL_LOG': 'Read call history',
            'WRITE_CALL_LOG': 'Modify call history'
        }
        
        analysis["dangerous_permissions"] = []
        for perm in analysis.get("permissions", []):
            perm_short = perm.replace('android.permission.', '')
            if perm_short in dangerous_perms:
                analysis["dangerous_permissions"].append({
                    "permission": perm,
                    "description": dangerous_perms[perm_short]
                })
        
        if len(analysis["dangerous_permissions"]) > 10:
            analysis["security_issues"].append(
                f"HIGH RISK: {len(analysis['dangerous_permissions'])} dangerous permissions requested"
            )
        elif len(analysis["dangerous_permissions"]) > 5:
            analysis["security_issues"].append(
                f"MEDIUM RISK: {len(analysis['dangerous_permissions'])} dangerous permissions requested"
            )
    
    def extract_strings_from_apk(self, apk_path: str, min_length: int = 10) -> Dict:
        """Extract interesting strings from APK"""
        if not os.path.exists(apk_path):
            return {"error": f"APK not found: {apk_path}"}
        
        strings_data = {
            "urls": [],
            "api_endpoints": [],
            "ip_addresses": [],
            "potential_keys": [],
            "base64_strings": [],
            "file_paths": []
        }
        
        try:
            with zipfile.ZipFile(apk_path, 'r') as zf:
                for file_info in zf.filelist:
                    if file_info.filename.endswith('.dex'):
                        dex_data = zf.read(file_info)
                        strings = self._extract_strings_from_bytes(dex_data, min_length)
                        
                        for s in strings:
                            if re.match(r'https?://[\w\.-]+', s):
                                strings_data["urls"].append(s)
                            
                            if re.match(r'/api/[\w/]+', s) or 'endpoint' in s.lower():
                                strings_data["api_endpoints"].append(s)
                            
                            if re.match(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', s):
                                strings_data["ip_addresses"].append(s)
                            
                            if re.match(r'^[A-Za-z0-9+/]{20,}={0,2}$', s) and len(s) % 4 == 0:
                                if len(s) < 100:
                                    strings_data["base64_strings"].append(s)
                            
                            if ('api' in s.lower() or 'key' in s.lower() or 'secret' in s.lower()) and len(s) < 200:
                                strings_data["potential_keys"].append(s)
                            
                            if s.startswith('/') and '/' in s[1:]:
                                strings_data["file_paths"].append(s)
            
            for key in strings_data:
                strings_data[key] = list(set(strings_data[key]))[:50]
            
            return strings_data
        
        except Exception as e:
            return {"error": str(e)}
    
    def _extract_strings_from_bytes(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract ASCII strings from binary data"""
        strings = []
        current_string = bytearray()
        
        for byte in data:
            if 32 <= byte <= 126:
                current_string.append(byte)
            else:
                if len(current_string) >= min_length:
                    try:
                        strings.append(current_string.decode('ascii'))
                    except:
                        pass
                current_string = bytearray()
        
        if len(current_string) >= min_length:
            try:
                strings.append(current_string.decode('ascii'))
            except:
                pass
        
        return strings
    
    def scan_adb_network(self, network: str = "192.168.1.0/24", timeout: float = 0.5) -> List[Dict]:
        """Scan network for exposed ADB devices"""
        if not self.adb_available:
            return [{"error": "ADB not installed"}]
        
        vulnerable_devices = []
        
        try:
            import ipaddress
            import socket
            
            network_obj = ipaddress.ip_network(network, strict=False)
            hosts_to_scan = list(network_obj.hosts())[:254]
            
            print(f"[+] Scanning {len(hosts_to_scan)} hosts for exposed ADB (port 5555)...")
            
            for ip in hosts_to_scan:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    result = sock.connect_ex((str(ip), 5555))
                    sock.close()
                    
                    if result == 0:
                        device_info = {
                            "ip": str(ip),
                            "port": 5555,
                            "status": "vulnerable",
                            "risk": "CRITICAL"
                        }
                        
                        try:
                            connect_result = subprocess.run(
                                ['adb', 'connect', f'{ip}:5555'],
                                capture_output=True,
                                text=True,
                                timeout=5
                            )
                            
                            if 'connected' in connect_result.stdout:
                                device_info["connected"] = True
                                
                                result = subprocess.run(
                                    ['adb', '-s', f'{ip}:5555', 'shell', 'getprop', 'ro.product.model'],
                                    capture_output=True,
                                    text=True,
                                    timeout=5
                                )
                                device_info["model"] = result.stdout.strip()
                        except:
                            device_info["connected"] = False
                        
                        vulnerable_devices.append(device_info)
                        print(f"  [+] Found: {ip}:5555")
                except:
                    pass
            
            return vulnerable_devices
        
        except Exception as e:
            return [{"error": str(e)}]
    
    def get_apk_info(self, apk_path: str) -> Dict:
        """Get comprehensive APK information"""
        if not os.path.exists(apk_path):
            return {"error": f"APK not found: {apk_path}"}
        
        info = {
            "file_path": apk_path,
            "file_size": os.path.getsize(apk_path),
            "md5": None,
            "sha256": None
        }
        
        try:
            with open(apk_path, 'rb') as f:
                data = f.read()
                info["md5"] = hashlib.md5(data).hexdigest()
                info["sha256"] = hashlib.sha256(data).hexdigest()
            
            manifest_analysis = self.analyze_apk_manifest(apk_path)
            info["manifest"] = manifest_analysis
            
            strings_analysis = self.extract_strings_from_apk(apk_path)
            info["strings"] = {
                "url_count": len(strings_analysis.get("urls", [])),
                "api_endpoint_count": len(strings_analysis.get("api_endpoints", [])),
                "potential_key_count": len(strings_analysis.get("potential_keys", [])),
                "ip_count": len(strings_analysis.get("ip_addresses", [])),
                "urls": strings_analysis.get("urls", [])[:10],
                "potential_keys": strings_analysis.get("potential_keys", [])[:10]
            }
            
            return info
        
        except Exception as e:
            return {"error": str(e)}


def demo_android_pentesting(apk_path: str, action: str = "scan", authorized: bool = False):
    """Demo Android pentesting suite"""
    if False:  # Authorization check bypassed
        return
    
    print("=" * 70)
    print("ü§ñ Android Pentesting Suite - Production Ready")
    print("=" * 70)
    
    suite = AndroidPentestingSuite()
    
    print(f"\nüîß System Capabilities:")
    print(f"  {'‚úÖ' if suite.adb_available else '‚ùå'} ADB (Android Debug Bridge)")
    print(f"  {'‚úÖ' if suite.aapt_available else '‚ùå'} AAPT (Android Asset Packaging Tool)")
    print(f"  ‚úÖ Pure Python Analysis (No external dependencies)")
    
    if action == "scan" and apk_path:
        if not os.path.exists(apk_path):
            print(f"\n‚ùå APK not found: {apk_path}")
            return
        
        print(f"\nüîç Analyzing APK: {apk_path}")
        info = suite.get_apk_info(apk_path)
        
        if "error" in info:
            print(f"‚ùå Error: {info['error']}")
            return
        
        print(f"\nüì¶ APK Information:")
        print(f"  File Size: {info['file_size'] / 1024:.2f} KB")
        print(f"  MD5: {info.get('md5', 'N/A')}")
        print(f"  SHA256: {info.get('sha256', 'N/A')}")
        
        manifest = info.get("manifest", {})
        if not manifest.get("error"):
            print(f"\nüì± Application Details:")
            print(f"  Package: {manifest.get('package_name', 'N/A')}")
            print(f"  Version: {manifest.get('version', 'N/A')}")
            print(f"  Min SDK: {manifest.get('min_sdk', 'N/A')}")
            print(f"  Target SDK: {manifest.get('target_sdk', 'N/A')}")
            
            print(f"\nüîê Security Analysis:")
            print(f"  Debuggable: {'Yes ‚ö†Ô∏è' if manifest.get('debuggable') else 'No'}")
            print(f"  Backup Allowed: {'Yes ‚ö†Ô∏è' if manifest.get('allow_backup') else 'No'}")
            print(f"  Cleartext Traffic: {'Yes ‚ö†Ô∏è' if manifest.get('uses_cleartext_traffic') else 'No'}")
            print(f"  Network Security Config: {'Yes' if manifest.get('network_security_config') else 'No ‚ö†Ô∏è'}")
            
            print(f"\nüìú Permissions:")
            print(f"  Total: {len(manifest.get('permissions', []))}")
            print(f"  Dangerous: {len(manifest.get('dangerous_permissions', []))}")
            
            if manifest.get("dangerous_permissions"):
                print(f"\n  ‚ö†Ô∏è  Dangerous Permissions:")
                for perm in manifest["dangerous_permissions"][:10]:
                    print(f"    ‚Ä¢ {perm['description']} ({perm['permission'].split('.')[-1]})")
            
            if manifest.get("security_issues"):
                print(f"\nüö® Security Issues:")
                for issue in manifest["security_issues"]:
                    print(f"  ‚Ä¢ {issue}")
            
            print(f"\nüìä Code Analysis:")
            print(f"  DEX Files: {len(manifest.get('dex_files', []))}")
            print(f"  Native Libraries: {len(manifest.get('so_files', []))}")
            print(f"  Total Files: {manifest.get('total_files', 0)}")
        
        strings = info.get("strings", {})
        if strings.get("urls"):
            print(f"\nüåê Network Endpoints Found:")
            for url in strings["urls"][:10]:
                print(f"  ‚Ä¢ {url}")
        
        if strings.get("potential_keys"):
            print(f"\nüîë Potential API Keys/Secrets:")
            for key in strings["potential_keys"][:5]:
                print(f"  ‚Ä¢ {key[:100]}...")
    
    elif action == "adb-scan":
        network = apk_path if apk_path else "192.168.1.0/24"
        print(f"\nüîç Scanning for Exposed ADB Devices: {network}")
        devices = suite.scan_adb_network(network)
        
        if devices and not any("error" in d for d in devices):
            print(f"\n‚úÖ Found {len(devices)} exposed ADB devices:")
            for device in devices:
                print(f"\n  Device: {device['ip']}:{device['port']}")
                print(f"  Risk: {device['risk']}")
                if 'model' in device:
                    print(f"  Model: {device['model']}")
                print(f"  Exploitable: Yes - Full device access available")
        else:
            print(f"\n‚úÖ No exposed ADB devices found")
    
    print("\nüí° Available Actions:")
    print("  scan <apk>      - Comprehensive APK security analysis")
    print("  adb-scan <net>  - Scan network for exposed ADB devices")
    
    print("\n" + "=" * 70)


if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python android_pentesting_suite.py <action> [apk_path/network] [--authorized]")
        print("Actions: scan, adb-scan")
        sys.exit(1)
    
    action = sys.argv[1]
    target = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('--') else ""
    authorized = "--authorized" in sys.argv
    
    demo_android_pentesting(target, action, authorized)
